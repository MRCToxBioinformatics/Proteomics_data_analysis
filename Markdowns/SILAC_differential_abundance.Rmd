---
title: "Differential abundance testing with SILAC ratios"
author: "Tom Smith"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
  pdf_document: default
bibliography: bib.json
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```


There are a number of statistical tests/R packages one can use to perform differential abundance testing for proteomics data. The list below is by no means complete:

- **t-test**: If we assume that the log-transformed SILAC ratios are Gaussian
distributed, a t-test may be appropriate when we have just one condition
(ratio is comparison of conditions = one-sample t-test) or two conditions
(ratio captures one condition, with another condition performed across samples = two-sample t-test)
- **ANOVA/linear model**: Where a more complex experimental design is involved,
an ANOVA or linear model can be used, on the same assumptions at the t-test.
- **`limma`** [@http://zotero.org/users/5634351/items/6KTXTWME]: Proteomics experiments are typically lowly replicated (e.g n << 10).
Variance estimates are therefore inaccurate. `limma`  is an R package that extends
the t-test/ANOVA/linear model testing framework to enable sharing of information
across features (here, proteins) to update the variance estimates. This decreases
false positives and increases statistical power.
- **`DEqMS`** [@http://zotero.org/users/5634351/items/RTM6NFVU]: limma assumes there is a relationship between protein abundance and
variance. This is usually the case, although
  - The relationship with variance is often stronger with the number of
  peptide spectrum matches, or peptides
  - For SILAC, the quantification value is the ratio, not protein abundance.
  There is no reason to believe there will be a relationship between the mean ratio and variance
  
  As such, `DEqMS` is preferred over limma for SILAC data.

### Load dependencies

Load the required libraries.

```{r, message=FALSE, warning=FALSE}
library(camprotR)
library(ggplot2)
library(MSnbase)
library(DEqMS)
library(limma)
library(dplyr)
library(tidyr)

```

Here, we will use the SILAC data processed in [Processing and QC of SILAC data](https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/Markdowns/SILAC.html). Please see the previous notebook for details of the experimental design and aim and data processing. 

In brief, we wish to determine the proteins which are significantly enriched by UV crosslinking (CL) vs non-CL control (NC).

```{r}
pep_res <- readRDS('results/pep_res.rds')
prot_res <- readRDS('results/prot_res.rds')
```


## Differential abundance testing

To identify proteins with significantly increased abundance in CL vs NC, we will use DEqMS [@http://zotero.org/users/5634351/items/RTM6NFVU], which you can think of as an extension of limma [@http://zotero.org/users/5634351/items/6KTXTWME] specifically for proteomics. 

The analysis steps are taken from the [DEqMS vignette](https://bioconductor.org/packages/release/bioc/vignettes/DEqMS/inst/doc/DEqMS-package-vignette.html#extract-quant-data-columns-for-deqms). The idea is that we want to create an `MArrayLM` object as per normal `limma` analysis and then  add a `$count` column to the `MArrayLM` object and then use the `spectraCounteBayes` function to perform the Bayesian shrinkage using the count column (which describes the number of pepitdes per protein) rather than the `$Amean` column (which describes the mean CL:NC ratio). 

First, we create the `MArrayLM` object. We filter out proteins with too few quantification values across the 4 replicates.
```{r}
dat <- prot_res %>% 
  filterNA(pNA = 0.5) %>% # select proteins in min. 2/4 reps
  exprs()

# Perfoming the equivalent of a one-sample t-test, so the design matrix is just an intercept
design <- cbind(Intercept = rep(1, ncol(dat))) 

fit <- lmFit(dat, design)
efit <- eBayes(fit)
```

Next, we define the `$count` column, which `DEqMS` will use. In the DEqMS paper,
they suggest that the best summarisation metric to use is the minimum value across
the samples, so our `count` columns is the minimum number of peptides per protein.  
```{r}
protein_ratio_long <- prot_res %>%
  exprs() %>%
  data.frame() %>%
  tibble::rownames_to_column('Master.Protein.Accessions') %>%
  pivot_longer(cols=-Master.Protein.Accessions, values_to='protein_ratio', names_to='sample')

# Obtain the min peptide count across the samples and determine the minimum value across 
# samples
min_pep_count <- camprotR::count_features_per_protein(pep_res) %>%
  merge(protein_ratio_long, by=c('Master.Protein.Accessions', 'sample')) %>%
  filter(is.finite(protein_ratio)) %>%  # We only want to consider samples with a ratio quantified
  group_by(Master.Protein.Accessions) %>%
  summarise(min_pep_count = min(n))

# add the min peptide count
efit$count <- min_pep_count %>% 
  filter(Master.Protein.Accessions %in% rownames(efit$coefficients)) %>% 
  pull(min_pep_count)
```

And now we run `spectraCounteBayes` from `DEqMS` to perform the statistical test.
```{r}
# run DEqMS
efit_deqms <- suppressWarnings(spectraCounteBayes(efit))
```

Below, we inspect the peptide count vs variance relationship which `DEqMS` is using in the statistical test.

In this case the relationship between peptide count and variance is only really apparent when the minimum number of peptides from which a protein-level ratio is obtained is very low. Typically, one might remove quantifications where there is just a single peptide for a protein. Here, have keep them, and we can refer to the `count` column in the final results object if we want to check the minimum number of peptides observed per sample.

```{r, fig.height=4, fig.width=4}
# Diagnostic plots
VarianceBoxplot(efit_deqms, n = 30, xlab = "Peptides")
```


Below, we summarise the number of proteins with statistically different abundance in CL vs NC and plot a 'volcano' plot to visualise this. Note that all proteins with a statistically significant change are increased in CL, so the plot looks more like a fire-hose than a volcano!

```{r, fig.height=5, fig.width=5}
deqms_results <- outputResult(efit_deqms, coef_col = 1)

table(ifelse(deqms_results$sca.adj.pval < 0.01, 'sig.', 'not sig.'),
      ifelse(deqms_results$logFC > 0, 'Higher in CL', 'Lower in CL'))

deqms_results %>%
  ggplot(aes(x = logFC, y = -log10(sca.P.Value), colour = sca.adj.pval < 0.01)) +
  geom_point() +
  theme_camprot() +
  scale_colour_manual(values = c('grey', get_cat_palette(2)[2]), name = 'CL vs NC Sig.') +
  labs(x = 'CL vs NC (Log2)', y = '-log10(p-value)')
```


Finally, we can explore and, if we wish, export our results. Importantly, the `$t`, `$P.Value` and `$adj.P.Val` columnts are from `limma`. The columns prefixed with `sca` are the from `DEqMS`. 

```{r}
head(deqms_results)

```
